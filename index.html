<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Pac-man multi-jugador</title>
<style>
  :root{--bg:#000}
  html,body{height:100%;margin:0;background:var(--bg);display:flex;align-items:center;justify-content:center;font-family:Arial}
  .wrap{width:94vw;max-width:760px;padding:12px;color:#9fd}
  canvas{display:block;width:100%;height:auto;border:6px solid #001f3f;background:#000;image-rendering:pixelated}
  .hud{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  button{padding:8px 10px;border-radius:8px;border:none;background:linear-gradient(90deg,#00e5ff,#9b5cff);cursor:pointer;color:#012}
  .panel{background:rgba(0,0,0,0.7);color:#def;padding:12px;border-radius:10px;text-align:center;max-width:86vw}
  #overlay{position:absolute;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
  #menu{display:flex;flex-direction:column;gap:8px;align-items:center}
  .btnBig{padding:10px 14px;border-radius:12px;background:linear-gradient(90deg,#ffd54d,#ff8a65);cursor:pointer;border:none}
  .small{font-size:12px;color:#9fd}
  .menu-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:center}
  select, label{color:#012;background:linear-gradient(90deg,#fff,#ddd);padding:6px;border-radius:6px;border:none}
  .player-box{background:rgba(255,255,255,0.03);padding:8px;border-radius:8px}
</style>
<link rel="icon" href="pacman.png" type="image/png">
</head>
<body>
<div class="wrap">
  <div class="hud">
    <div><strong id="score">Puntos: 0</strong></div>
    <div>
      <button id="btnRestart">Reiniciar (R)</button>
      <button id="btnSound">Sonido: ON</button>
    </div>
    <div><strong id="lives">Vidas: 3</strong></div>
  </div>

  <div style="position:relative">
    <canvas id="c" width="448" height="496" aria-label="Pacman game"></canvas>
    <div id="overlay" style="display:flex;pointer-events:none">
      <div class="panel" id="panelText"></div>
    </div>
  </div>

  <p style="color:#ff0000;margin-top:8px;font-size:13px">
    Pac-man, atencion este juego se puede escoger el jugador pero no pueden dos personas ser fantasmas si no una fantasmas y la otra pac-man, no recomendamos jugar este juego en pc pequeñas
      dia lanzado: 3 de dicembre del 2025
      lugar donde se creo: arica, chile.
  </p>
  <p style="color:#jf0567;margin-top:8px;font-size:13px">
      proxima actualizacion 1.0.9 el 10 de junio del 2026: se trata de tres jugadores podran jugar como fantasmas y escogeran si son un jugador o dos jugadores o tres jugadores 
  </p>
</div>
<script>
/* ---------- Config ---------- */
const COLS = 28, ROWS = 31;
const TILE = 16;
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const overlay = document.getElementById('overlay');
const panelText = document.getElementById('panelText');
const btnRestart = document.getElementById('btnRestart');
const btnSound = document.getElementById('btnSound');

let soundOn = true;

/* audio */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx=null, master=null;
function ensureAudio(){ if(!audioCtx){ audioCtx=new AudioCtx(); master=audioCtx.createGain(); master.gain.value=0.12; master.connect(audioCtx.destination);} }
function playTone(freq,dur=0.08,type='sine',vol=0.06){ if(!audioCtx||!soundOn) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=vol; o.connect(g); g.connect(master); const now=audioCtx.currentTime; o.start(now); g.gain.exponentialRampToValueAtTime(0.0001, now+dur); o.stop(now+dur+0.02); }
function sfxEat(){ playTone(880,0.05,'sine',0.06); }
function sfxPower(){ playTone(420,0.22,'triangle',0.09); }
function sfxEatGhost(){ playTone(1320,0.18,'square',0.07); }
function sfxDeath(){ playTone(120,0.8,'sawtooth',0.12); }
function sfxWin(){ playTone(1000,0.25,'sine',0.12); playTone(1400,0.22,'sine',0.08); }

/* ---------- Mapa (tu original) ---------- */
const MAP_RAW = [
"WWWWWWWWWWWWWWWWWWWWWWWWWWww",
"W............WW............W",
"W.WWWW.WWWWW.WW.WWWWW.WWWW.W",
"WoWWWW.WWWWW.WW.WWWWW.WWWWoW",
"W.WWWW.WWWWW.WW.WWWWW.WWWW.W",
"W..........................W",
"W.WWWW.WW.WWWWWWWW.WW.WWWW.W",
"W.WWWW.WW.WWWWWWWW.WW.WWWW.W",
"W......WW....WW....WW......W",
"WWWWWW.WWWWW WW WWWWW.WWWWWW",
"     W.WWWWW WW WWWWW.W     ",
"     W.WW          WW.W     ",
"     W.WW WWW__WWW WW.W     ",
"WWWWWW.WW W      W WW.WWWWWW",
"      .   W      W   .      ",
"WWWWWW.WW W      W WW.WWWWWW",
"     W.WW WWWWWWWW WW.W     ",
"     W.WW          WW.W     ",
"     W.WW WWWWWWWW WW.W     ",
"WWWWWW.WW WWWWWWWW WW.WWWWWW",
"W............WW............W",
"W.WWWW.WWWWW.WW.WWWWW.WWWW.W",
"W.WWWW.WWWWW.WW.WWWWW.WWWW.W",
"Wo..WW................WW..oW",
"WWW.WW.WW.WWWWWWWW.WW.WW.WWW",
"WWW.WW.WW.WWWWWWWW.WW.WW.WWW",
"W......WW....WW....WW......W",
"W.WWWWWWWWWW.WW.WWWWWWWWWW.W",
"W..........................W",
"WWWWWWWWWWWWWWWWWWWWWWWWWWWW"
];
for(let i=0;i<MAP_RAW.length;i++){ if(typeof MAP_RAW[i]!=='string') MAP_RAW[i]=''.padEnd(COLS,' '); if(MAP_RAW[i].length<COLS) MAP_RAW[i]=MAP_RAW[i].padEnd(COLS,' '); if(MAP_RAW[i].length>COLS) MAP_RAW[i]=MAP_RAW[i].slice(0,COLS); }
let MAP = MAP_RAW.map(r => r.split('').map(ch => ch==='_' ? ' ' : ch));

function getCell(r,c){ if(r<0||r>=ROWS||c<0||c>=COLS) return 'W'; const row = MAP[r]; if(!row) return ' '; return row[c] || ' '; }

/* ---------- Estado ---------- */
let score = 0;
let lives = 3;
let running = false;
let powerMode = false;
let powerExpire = 0;

/* ---------- Players ---------- */
let pac1 = { x:13.5, y:23, dir:{x:0,y:0}, next:{x:0,y:0}, speed:0.09, lastDir:{x:1,y:0}, anim:0, color:'#ffd84d', type:'pacman', active:true };
let pac2 = { x:14.5, y:23, dir:{x:0,y:0}, next:{x:0,y:0}, speed:0.09, lastDir:{x:-1,y:0}, anim:0, color:'#8cffb8', type:'pacman', active:true };

/* ---------- Ghosts ---------- */
let ghosts = [];
function resetGhosts(){
  ghosts = [
    {name:'Blinky', x:13.5, y:11, dir:{x:0,y:0}, next:{x:0,y:0}, color:'#ff0000', speed:0.06, vulnerable:false, eaten:false, scatterTarget:[26,0]},
    {name:'Pinky',  x:13.5, y:13, dir:{x:0,y:0}, next:{x:0,y:0}, color:'#ff71b8', speed:0.055, vulnerable:false, eaten:false, scatterTarget:[1,0]},
    {name:'Inky',   x:12.5, y:13, dir:{x:0,y:0}, next:{x:0,y:0}, color:'#00f0ff', speed:0.05, vulnerable:false, eaten:false, scatterTarget:[26,30]},
    {name:'Clyde',  x:14.5, y:13, dir:{x:0,y:0}, next:{x:0,y:0}, color:'#ffb86b', speed:0.047, vulnerable:false, eaten:false, scatterTarget:[0,30]}
  ];
  const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
  ghosts.forEach(g => {
    const valid = dirs.filter(d => {
      const tx = Math.floor(g.x + d.x*0.6), ty = Math.floor(g.y + d.y*0.6);
      return !isWallTileXY(tx, ty);
    });
    g.dir = valid.length ? valid[Math.floor(Math.random()*valid.length)] : {x:0,y:0};
    g.vulnerable = false; g.eaten = false; g.next={x:0,y:0};
  });
}
resetGhosts();

function pacAIDecide(pac){
  if(!pac.active) return;
  const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
  const cx = Math.floor(pac.x), cy = Math.floor(pac.y);

  // Encuentra la dirección hacia el pellet más cercano (simple BFS)
  let target = null;
  outer: for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const ch = getCell(r,c);
      if(ch==='.'||ch==='o'){ target={r,c}; break outer; }
    }
  }
  if(!target) return;

  // Mueve pac hacia el objetivo de forma simple
  let bestDir = pac.dir;
  let bestDist = 1e9;
  dirs.forEach(d=>{
    const nx = pac.x + d.x*0.3;
    const ny = pac.y + d.y*0.3;
    if(canMoveTo(nx,ny)){
      const dist = Math.hypot(target.c - nx, target.r - ny);
      if(dist < bestDist){ bestDist = dist; bestDir = d; }
    }
  });
  pac.next = bestDir;
}

   function showPacBlinkyAnimation(done){
  const duration = 2200;
  const start = performance.now();
  const origRunning = running;
  running = false;
  const savedOverlay = overlay.style.display;
  overlay.style.display='none';

  function anim(now){
    const t = now - start;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // dibujar mapa base
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const ch=getCell(r,c), x=c*TILE, y=r*TILE;
        ctx.fillStyle=(ch==='W')?'#001f5a':'#000';
        ctx.fillRect(x,y,TILE,TILE);
      }
    }

    const pct = Math.min(1, t/duration);
    const px = 10 + pct*(canvas.width - 60);
    const bx = Math.max(6, px - 28 - Math.sin(pct*Math.PI*4)*6);

    // Dibujar Pac-Man jugador 1 y 2 si activos
    if(pac1.active) drawCelebrationPac(px, canvas.height/2-30, Math.sin(t/150), pac1.color);
    if(pac2.active) drawCelebrationPac(px, canvas.height/2+10, Math.sin(t/150), pac2.color);
    // Blinky siempre
    drawCelebrationGhost(bx, canvas.height/2-10, '#ff0000');

    // texto
    ctx.fillStyle='#fff'; ctx.font='18px Arial'; ctx.fillText('¡Victoria consecutiva!', 12, 26);

    if(t < duration) requestAnimationFrame(anim);
    else {
      overlay.style.display = savedOverlay;
      running = origRunning;
      if(done) done();
    }
  }
  requestAnimationFrame(anim);
}
 
    
/* controlledGhosts[gi] = 'p1' | 'p2' | null  */
let controlledGhosts = [null,null,null,null];

/* ---------- Funciones de colisión y movimiento ---------- */
function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }
function isWallTileXY(x,y){ let c=Math.floor(x), r=Math.floor(y); if(r<0||r>=ROWS) return true; if(c<0) c=COLS-1; if(c>=COLS)c=0; return getCell(r,c)==='W'; }
function canMoveTo(x,y){ if(Math.floor(y)<0||Math.floor(y)>=ROWS) return false; if(x<0)x=COLS-0.001; if(x>=COLS)x=0.001; return !isWallTileXY(x,y); }

function consumeAt(entity){
  const r = Math.floor(entity.y), c = Math.floor(entity.x);
  if(!inBounds(r,c)) return;
  const ch = getCell(r,c);
  if(ch==='.'){ MAP[r][c]=' '; score+=10; sfxEat(); updateHUD(); }
  if(ch==='o'){ MAP[r][c]=' '; score+=50; sfxPower(); powerOn(); updateHUD(); }
}
function powerOn(){ powerMode=true; powerExpire=performance.now()+10000; ghosts.forEach(g=>{ g.vulnerable=true; g.eaten=false; }); }
function eatGhost(g){ score+=200; sfxEatGhost(); g.eaten=true; g.vulnerable=false; setTimeout(()=>{ g.x=13.5; g.y=13; g.eaten=false; g.vulnerable=false; },900); updateHUD(); }

function checkGhostCollisionsPac(entity){
  ghosts.forEach(g=>{
    if(g.eaten) return;
    const dx = g.x - entity.x, dy = g.y - entity.y;
    if(dx*dx + dy*dy < 0.36){
      if(g.vulnerable) eatGhost(g);
      else{
        lives--; updateHUD(); sfxDeath();
        if(entity===pac1){ pac1.x=13.5; pac1.y=23; pac1.dir={x:0,y:0}; pac1.next={x:0,y:0}; pac1.lastDir={x:1,y:0}; }
        if(entity===pac2){ pac2.x=14.5; pac2.y=23; pac2.dir={x:0,y:0}; pac2.next={x:0,y:0}; pac2.lastDir={x:-1,y:0}; }
        resetGhosts();
        if(lives<=0){ running=false; showMenu('GAME OVER'); }
      }
    }
  });
}

/* ---------- Ghost AI ---------- */
function ghostDecide(g){
  // If player is pushing a direction (next) for this ghost, apply it when possible
  if(g.next && (g.next.x!==0 || g.next.y!==0)){
    const testX=g.x+g.next.x*0.35, testY=g.y+g.next.y*0.35;
    if(canMoveTo(testX,testY)){ g.dir={...g.next}; g.next={x:0,y:0}; return; }
  }

  const cx=Math.floor(g.x), cy=Math.floor(g.y);
  if(Math.abs(g.x-(cx+0.5))>0.18 || Math.abs(g.y-(cy+0.5))>0.18) return;
  const options=[]; const dirs=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
  dirs.forEach(d=>{
    const nx=Math.floor(g.x+d.x*0.6), ny=Math.floor(g.y+d.y*0.6);
    if(!isWallTileXY(nx,ny)){ if(d.x===-g.dir.x && d.y===-g.dir.y) return; options.push(d); }
  });
  if(options.length===0){ g.dir={x:-g.dir.x,y:-g.dir.y}; return; }
  let best=options[0];
  if(!g.vulnerable){
    let bestd=1e9;
    options.forEach(op=>{ const tx=g.x+op.x, ty=g.y+op.y; const d2=(tx-pac1.x)*(tx-pac1.x)+(ty-pac1.y)*(ty-pac1.y); if(d2<bestd){ bestd=d2; best=op; } });
  } else{
    let bestd=-1;
    options.forEach(op=>{ const tx=g.x+op.x, ty=g.y+op.y; const d2=(tx-pac1.x)*(tx-pac1.x)+(ty-pac1.y)*(ty-pac1.y); if(d2>bestd){ bestd=d2; best=op; } });
  }
  g.dir=best;
}

/* ---------- Try turn ---------- */
function tryTurn(entity){
  const cx=Math.floor(entity.x)+0.5, cy=Math.floor(entity.y)+0.5;
  if(entity.next.x=== -entity.dir.x && entity.next.y=== -entity.dir.y){ entity.dir={...entity.next}; entity.next={x:0,y:0}; return; }
  if(entity.next.x!==0||entity.next.y!==0){
    const testX=entity.x+entity.next.x*0.35, testY=entity.y+entity.next.y*0.35;
    if(canMoveTo(testX,testY)){ if(Math.abs(entity.x-cx)<0.3 && Math.abs(entity.y-cy)<0.3){ entity.x=cx; entity.y=cy; } entity.dir={...entity.next}; entity.next={x:0,y:0}; return; }
  }
  if(Math.abs(entity.x-cx)<0.15 && Math.abs(entity.y-cy)<0.15){
    if(entity.next.x!==0||entity.next.y!==0){ const nx=entity.x+entity.next.x*0.55, ny=entity.y+entity.next.y*0.55; if(canMoveTo(nx,ny)){ entity.dir={...entity.next}; entity.next={x:0,y:0}; entity.x=cx; entity.y=cy; return; } }
    const mx=entity.x+entity.dir.x*0.3, my=entity.y+entity.dir.y*0.3; if(!canMoveTo(mx,my)){ entity.x=Math.round(entity.x*100)/100; entity.y=Math.round(entity.y*100)/100; entity.dir={x:0,y:0}; } 
  }
}

/* ---------- Sprites ---------- */
function drawPacSprite(sx, sy, dir, anim, color){
  const px=Math.floor(sx), py=Math.floor(sy), size=TILE, centerX=px+size/2, centerY=py+size/2;
  const mouth=0.2+0.35*Math.abs(Math.sin(anim));
  let angle=0; if(dir.x===1)angle=0; if(dir.x===-1)angle=Math.PI; if(dir.y===-1)angle=-Math.PI/2; if(dir.y===1)angle=Math.PI/2;
  ctx.fillStyle=color; ctx.beginPath(); ctx.moveTo(centerX,centerY); ctx.arc(centerX,centerY,size/2-1,angle+mouth,angle-mouth,false); ctx.closePath(); ctx.fill();
  ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(centerX+(dir.x*2-dir.y*0.5)*2, centerY+(dir.y*2+dir.x*0.5)*2, Math.max(1,size*0.06),0,Math.PI*2); ctx.fill();
}

/* ghost draw same as before */
const ghostMatrix=[
  [null,'c','c','c','c','c','c',null],
  ['c','c','c','c','c','c','c','c'],
  ['c','c','c','c','c','c','c','c'],
  ['c','c','c','c','c','c','c','c'],
  ['c','c','c','c','c','c','c','c'],
  ['c','w','w','w','w','w','w','c'],
  ['c','w','w','w','w','w','w','c'],
  ['w','w','w','w','w','w','w','w']
];
function drawGhostPixel(sx, sy, color, vulnerable){
  const px=Math.floor(sx), py=Math.floor(sy), cell=TILE/8;
  for(let r=0;r<8;r++){ for(let c=0;c<8;c++){
    const v=ghostMatrix[r][c]; if(v===null)continue;
    if(v==='w'){ ctx.fillStyle='#fff'; ctx.fillRect(px+c*cell, py+r*cell, cell, cell); }
    else{ if(vulnerable){ const flash=(powerMode&&powerExpire-performance.now()<3000)?Math.floor(performance.now()/200)%2:1; ctx.fillStyle=flash?'#6fa8ff':'#fff'; }else ctx.fillStyle=color; ctx.fillRect(px+c*cell, py+r*cell, cell, cell); }
  }}
  ctx.fillStyle='#000'; ctx.fillRect(px+2*cell+Math.floor(cell/2), py+2*cell+Math.floor(cell/2), Math.max(1,cell/1.5), Math.max(1,cell/1.5));
  ctx.fillRect(px+5*cell+Math.floor(cell/2), py+2*cell+Math.floor(cell/2), Math.max(1,cell/1.5), Math.max(1,cell/1.5));
}

/* ---------- Draw completo ---------- */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let r=0;r<ROWS;r++){ for(let c=0;c<COLS;c++){
    const ch=getCell(r,c), x=c*TILE, y=r*TILE;
    if(ch==='W'){ ctx.fillStyle='#001f5a'; ctx.fillRect(x,y,TILE,TILE); ctx.fillStyle='#002b7a'; ctx.fillRect(x+2,y+2,TILE-4,TILE-4); }
    else ctx.fillStyle='#000', ctx.fillRect(x,y,TILE,TILE);
    if(ch==='.'){ ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(x+TILE/2,y+TILE/2,Math.max(1,TILE*0.06),0,Math.PI*2); ctx.fill(); }
    if(ch==='o'){ ctx.fillStyle='#ffd166'; ctx.beginPath(); ctx.arc(x+TILE/2,y+TILE/2,Math.max(2,TILE*0.12),0,Math.PI*2); ctx.fill(); }
  }}

  ghosts.forEach(g=>{
    const sx=Math.floor((g.x-0.5)*TILE), sy=Math.floor((g.y-0.5)*TILE);
    if(g.eaten){ const ex=Math.floor(g.x*TILE), ey=Math.floor(g.y*TILE); ctx.fillStyle='#fff'; ctx.fillRect(ex+6,ey+6,3,3); ctx.fillRect(ex+11,ey+6,3,3); }
    else drawGhostPixel(sx, sy, g.color, g.vulnerable);
  });

  if(pac1.active) drawPacSprite(Math.floor((pac1.x-0.5)*TILE), Math.floor((pac1.y-0.5)*TILE), pac1.lastDir, pac1.anim, pac1.color);
  if(pac2.active) drawPacSprite(Math.floor((pac2.x-0.5)*TILE), Math.floor((pac2.y-0.5)*TILE), pac2.lastDir, pac2.anim, pac2.color);
}

/* ---------- Update ---------- */
let last = performance.now();
function update(now){
  if(!running){ last=now; draw(); return; }
  const dt=now-last; last=now;

  pac1.anim+=dt/120; pac2.anim+=dt/120;
  if(powerMode && performance.now()>powerExpire){ powerMode=false; ghosts.forEach(g=>g.vulnerable=false); }

  [pac1,pac2].forEach(p=>{
    if(!p.active) return;
    tryTurn(p);
    const step=p.speed*(dt/16.67), nx=p.x+p.dir.x*step, ny=p.y+p.dir.y*step;
    p.x=canMoveTo(nx,ny)?nx:(Math.round(p.x*100)/100);
    p.y=canMoveTo(nx,ny)?ny:(Math.round(p.y*100)/100);
    if(p.dir.x!==0||p.dir.y!==0) p.lastDir={...p.dir};
    consumeAt(p);
    checkGhostCollisionsPac(p);
  });

  ghosts.forEach((g,gi)=>{
    // If this ghost is controlled by a player, we do NOT run full AI.
    if(controlledGhosts[gi] !== null){
      // apply player input which will be set by key handlers (g.next already updated)
      if(g.next && (g.next.x!==0 || g.next.y!==0)){
        const testX=g.x+g.next.x*0.35, testY=g.y+g.next.y*0.35;
        if(canMoveTo(testX,testY)){ g.dir={...g.next}; g.next={x:0,y:0}; }
      }
      // no ghostDecide for controlled ghosts
    } else {
      ghostDecide(g);
    }

    const gstep=g.speed*(dt/16.67)*(g.eaten?1.6:1);
    let gx=g.x+g.dir.x*gstep, gy=g.y+g.dir.y*gstep;
    if(gx<0)gx=COLS-0.001;if(gx>=COLS)gx=0.001;
    if(canMoveTo(gx,gy)) { g.x=gx; g.y=gy; } else { const opts=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}].filter(d=>!isWallTileXY(Math.floor(g.x+d.x*0.6),Math.floor(g.y+d.y*0.6))); g.dir=opts.length?opts[Math.floor(Math.random()*opts.length)]:{x:-g.dir.x,y:-g.dir.y}; }
  });

  let pellets=0; for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){ const ch=getCell(r,c); if(ch==='.'||ch==='o') pellets++; }
  if(pellets===0){ running=false; sfxWin(); handleLevelWin(); }

  draw();
}
function frame(now){ update(now); requestAnimationFrame(frame); }
requestAnimationFrame(frame);

/* ---------- Input ---------- */
// Key handling: arrows = p1, WASD = p2. If a player controls some ghosts, their keys route to those ghosts.
window.addEventListener('keydown', e=>{
  ensureAudio();
  const k=e.key;

  // Helper: route input for player 'p1' or 'p2'
  function routeToPlayer(player, dir){
    // First, send to ghosts controlled by this player
    let sentToGhost=false;
    controlledGhosts.forEach((who,gi)=>{ if(who===player){ ghosts[gi].next = dir; sentToGhost=true; } });
    // If no ghost controlled by this player, send to that player's pacman
    if(!sentToGhost){
      if(player==='p1') pac1.next = dir;
      if(player==='p2') pac2.next = dir;
    }
  }

  if(k==='ArrowLeft') routeToPlayer('p1',{x:-1,y:0});
  if(k==='ArrowRight') routeToPlayer('p1',{x:1,y:0});
  if(k==='ArrowUp') routeToPlayer('p1',{x:0,y:-1});
  if(k==='ArrowDown') routeToPlayer('p1',{x:0,y:1});

  if(k==='a'||k==='A') routeToPlayer('p2',{x:-1,y:0});
  if(k==='d'||k==='D') routeToPlayer('p2',{x:1,y:0});
  if(k==='w'||k==='W') routeToPlayer('p2',{x:0,y:-1});
  if(k==='s'||k==='S') routeToPlayer('p2',{x:0,y:1});

  if(k==='r'||k==='R'){ restart(); return; }
  if(k===' '){ running=!running; if(!running) showOverlay('PAUSA'); else hideOverlay(); return; }
});
btnRestart.addEventListener('click', restart);
btnSound.addEventListener('click', ()=>{ soundOn=!soundOn; btnSound.textContent='Sonido: '+(soundOn?'ON':'OFF'); });

/* ---------- HUD / UI ---------- */
function updateHUD(){ scoreEl.textContent='Puntos: '+score; livesEl.textContent='Vidas: '+lives; }
function showOverlay(html){ panelText.innerHTML=html; overlay.style.display='flex'; overlay.style.pointerEvents='auto'; }
function hideOverlay(){ overlay.style.display='none'; overlay.style.pointerEvents='none'; }

/* ---------- Win tracking for animation ---------- */
let lastWinner = null; // 'p1' | 'p2' | 'none'
let winStreak = 0;

/* ---------- Handle level win and animation ---------- */
function determineWinner(){
  // Determine winner by comparing scores of active players. If both inactive -> none.
  const p1Score = pac1.active ? scorePlayerScores.p1 : -1;
  const p2Score = pac2.active ? scorePlayerScores.p2 : -1;
  if(p1Score===p2Score) return 'none';
  return (p1Score>p2Score)?'p1':'p2';
}

// We'll store the players' scores separately so we can compare
let scorePlayerScores = { p1:0, p2:0 };

function handleLevelWin(){
  // Capture player scores (approx: players get portions of overall score by their consumes)
  // For simplicity, we assume contributions from pac1/pac2 are proportional to their current score deltas tracked per-player.
  // We'll approximate: if both active, we split score by checking collected pellets counted earlier is complex.
  // Simpler practical approach: track scores during gameplay per-player. We'll maintain local per-player increments.
  // If not available, fallback to comparing same global score but we have been updating per-player earlier?
  // Implement per-player scoring now: we already call consumeAt for each pac; to track that we modify consumeAt to accept entity and add to per-player
  // BUT that would be intrusive; to keep it simple here, we'll use the current global 'score' and attribute it to the active pac that last consumed.
  // To get a functional result, we will store lastEater variable updated on consumeAt; already not implemented — add now.

  // Use lastEater to decide who won (lastEater = 'p1'/'p2' ). If not available, compare pac1 and pac2 active states and fallback to p1.
  const winner = lastEater || (pac1.active? 'p1' : (pac2.active? 'p2':'none'));
  showMenu(winner === 'p1' ? '¡Jugador 1 gana!' : (winner==='p2' ? '¡Jugador 2 gana!' : 'EMPATE'));
  // update streak
  if(winner === lastWinner && winner !== 'none') winStreak++; else winStreak = 1;
  lastWinner = winner;

  // If streak >= 2 => show special animation after short delay
  if(winStreak >= 2 && winner !== 'none'){
    setTimeout(()=>{ showPacBlinkyAnimation(()=>{ /* after animation, do new level */ restart(); }); }, 350);
  } else {
    // prepare next round after short pause
    setTimeout(()=>{ restart(); }, 900);
  }
}

/* track last eater for winner determination */
let lastEater = null;

/* Update consumeAt to register eater */
function consumeAt(entity){
  const r = Math.floor(entity.y), c = Math.floor(entity.x);
  if(!inBounds(r,c)) return;
  const ch = getCell(r,c);
  if(ch==='.'){ MAP[r][c]=' '; score+=10; sfxEat(); updateHUD(); if(entity===pac1) { scorePlayerScores.p1 += 10; lastEater='p1'; } else if(entity===pac2){ scorePlayerScores.p2 += 10; lastEater='p2'; } }
  if(ch==='o'){ MAP[r][c]=' '; score+=50; sfxPower(); powerOn(); updateHUD(); if(entity===pac1) { scorePlayerScores.p1 += 50; lastEater='p1'; } else if(entity===pac2){ scorePlayerScores.p2 += 50; lastEater='p2'; } }
}

/* ---------- Animation: Pac-Man + Blinky celebration ---------- */
function showPacBlinkyAnimation(done){
  // Simple animation: Pac-Man moves from left to right with Blinky chasing, flashing, plus text.
  const duration = 2200;
  const start = performance.now();
  const origRunning = running;
  running = false;
  const savedOverlay = overlay.style.display;
  overlay.style.display='none';

  function anim(now){
    const t = now - start;
    // clear and draw base map
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let r=0;r<ROWS;r++){ for(let c=0;c<COLS;c++){
      const ch=getCell(r,c), x=c*TILE, y=r*TILE;
      if(ch==='W'){ ctx.fillStyle='#001f5a'; ctx.fillRect(x,y,TILE,TILE); ctx.fillStyle='#002b7a'; ctx.fillRect(x+2,y+2,TILE-4,TILE-4); }
      else ctx.fillStyle='#000', ctx.fillRect(x,y,TILE,TILE);
    }}
    // compute positions
    const pct = Math.min(1, t/duration);
    const px = 10 + pct*(canvas.width - 60);
    const bx = Math.max(6, px - 28 - Math.sin(pct*Math.PI*4)*6);

    // draw pacman (facing right)
    drawCelebrationPac(px, canvas.height/2 - 20, Math.sin(t/150), '#ffd84d');
    // draw blinky as pixel ghost
    drawCelebrationGhost(bx, canvas.height/2 - 24, '#ff0000');

    // text
    ctx.fillStyle='#fff'; ctx.font='18px Arial'; ctx.fillText('¡Victoria consecutiva!', 12, 26);

    if(t < duration) requestAnimationFrame(anim);
    else {
      // restore
      overlay.style.display = savedOverlay;
      running = origRunning;
      if(done) done();
    }
  }
  requestAnimationFrame(anim);
}
function drawCelebrationPac(cx, cy, anim, color){
  const size=32;
  ctx.save();
  ctx.translate(cx,cy);
  const mouth = 0.2 + 0.35*Math.abs(Math.sin(anim));
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.arc(0,0,size/2-1,-mouth, mouth,false);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(6,-2,3,0,Math.PI*2); ctx.fill();
  ctx.restore();
}
function drawCelebrationGhost(cx, cy, color){
  const size=28;
  const px = cx;
  const py = cy;
  // simple rounded ghost body
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(px+size/2, py+size/2 - 4, size/2 - 1, Math.PI, 0);
  ctx.rect(px, py+size/2 - 4, size, size/2 + 4);
  ctx.fill();
  // eyes
  ctx.fillStyle='#fff'; ctx.fillRect(px+6, py+6, 6, 6); ctx.fillRect(px+16, py+6, 6, 6);
  ctx.fillStyle='#000'; ctx.fillRect(px+8, py+8, 3, 3); ctx.fillRect(px+18, py+8, 3, 3);
}

/* ---------- Menu (reemplaza la versión anterior) ---------- */
function showMenu(title){
  // menu HTML: assign roles for player1 & player2
  const html = `
    <div id="menu">
      <h2>Pac-man version 1.0.0</h2>
      <div class="small">Controles: Flechas (Jugador 1) + WASD (Jugador 2) — Espacio pausa — R reiniciar</div>
      <div style="height:8px"></div>

      <div class="menu-row" style="width:100%;justify-content:space-around;">
        <div class="player-box">
          <div><strong>Jugador 1</strong></div>
          <div class="small">Control: Flechas</div>
          <div style="height:6px"></div>
          <label>Elige personaje:</label><br>
          <select id="roleP1">
            <option value="pac">Pac-Man</option>
            <option value="g0">Blinky (rojo)</option>
            <option value="g1">Pinky (rosado)</option>
            <option value="g2">Inky (celeste)</option>
            <option value="g3">Clyde (naranja)</option>
            <option value="none">Nadie</option>
          </select>
          <div style="height:8px"></div>
          <label>Color Pac-Man</label><br>
          <input id="colorP1" type="color" value="${pac1.color}">
        </div>

        <div class="player-box">
          <div><strong>Jugador 2</strong></div>
          <div class="small">Control: WASD</div>
          <div style="height:6px"></div>
          <label>Elige personaje:</label><br>
          <select id="roleP2">
            <option value="pac">Pac-Man</option>
            <option value="g0">Blinky (rojo)</option>
            <option value="g1">Pinky (rosado)</option>
            <option value="g2">Inky (celeste)</option>
            <option value="g3">Clyde (naranja)</option>
            <option value="none">Nadie</option>
          </select>
          <div style="height:8px"></div>
          <label>Color Pac-Man</label><br>
          <input id="colorP2" type="color" value="${pac2.color}">
        </div>
      </div>

      <div style="height:8px"></div>
      <div class="small">Nota: Si eliges un fantasma, usarás tu set de teclas para controlarlo en el juego.</div>
      <div style="height:8px"></div>
      <button class="btnBig" id="startBtn">Comenzar</button>
    </div>
  `;
  showOverlay(html);

  // after overlay is attached to DOM, wire up controls
  const colorP1 = document.getElementById('colorP1');
  const colorP2 = document.getElementById('colorP2');
  const roleP1 = document.getElementById('roleP1');
  const roleP2 = document.getElementById('roleP2');

  // set initial values
  colorP1.value = pac1.color || '#dh5555';
  colorP2.value = pac2.color || '#dej5186';
  // default roles: pac
  roleP1.value = pac1.type === 'pacman' ? 'pac' : (pac1.type && pac1.type.startsWith('g')? pac1.type : 'pac');
  roleP2.value = pac2.type === 'pacman' ? 'pac' : (pac2.type && pac2.type.startsWith('g')? pac2.type : 'pac');

  document.getElementById('startBtn').addEventListener('click', ()=>{
    // apply settings
    pac1.color = colorP1.value;
    pac2.color = colorP2.value;

    // reset controlledGhosts
    controlledGhosts = [null,null,null,null];
    // reset player score trackers
    scorePlayerScores = { p1:0, p2:0 };
    lastEater = null;

    // Role P1
    const r1 = roleP1.value;
    if(r1 === 'pac'){ pac1.active = true; pac1.type = 'pacman'; }
    else if(r1 === 'none'){ pac1.active = false; pac1.type = 'none'; }
    else { pac1.active = false; pac1.type = r1; const gi = parseInt(r1.slice(1),10); controlledGhosts[gi] = 'p1'; }

    // Role P2
    const r2 = roleP2.value;
    if(r2 === 'pac'){ pac2.active = true; pac2.type = 'pacman'; }
    else if(r2 === 'none'){ pac2.active = false; pac2.type = 'none'; }
    else { pac2.active = false; pac2.type = r2; const gi = parseInt(r2.slice(1),10); controlledGhosts[gi] = 'p2'; }

    hideOverlay();
    running = true;
    ensureAudio();
  });
}

/* ---------- Reiniciar ---------- */
function restart(){
  MAP = MAP_RAW.map(r=>r.split('').map(ch => ch==='_'?' ':ch));
  score=0; lives=3; powerMode=false;
  // preserve colors and assigned roles (pac1.type/pac2.type)
  pac1 = { x:13.5, y:23, dir:{x:0,y:0}, next:{x:0,y:0}, speed:0.09, lastDir:{x:1,y:0}, anim:0, color:pac1.color || '#ffd84d', type:pac1.type||'pacman', active:true };
  pac2 = { x:14.5, y:23, dir:{x:0,y:0}, next:{x:0,y:0}, speed:0.09, lastDir:{x:-1,y:0}, anim:0, color:pac2.color || '#8cffb8', type:pac2.type||'pacman', active:true };

  // set pac active based on type preserved
  pac1.active = (pac1.type === 'pacman');
  pac2.active = (pac2.type === 'pacman');

  // reset ghosts and reapply controlledGhosts based on types
  resetGhosts();
  // if roles were stored as g0..g3, ensure controlledGhosts reflect them (we already set controlledGhosts in menu)
  // but in case roles changed externally, rebuild controlledGhosts
  controlledGhosts = [null,null,null,null];
  if(pac1.type && pac1.type.startsWith('g')){ controlledGhosts[parseInt(pac1.type.slice(1),10)] = 'p1'; }
  if(pac2.type && pac2.type.startsWith('g')){ controlledGhosts[parseInt(pac2.type.slice(1),10)] = 'p2'; }

  // reset per-player scores
  scorePlayerScores = { p1:0, p2:0 };
  lastEater = null;

  updateHUD();
}

/* ---------- Inicial ---------- */
updateHUD();
showMenu('PAC-MAN 2026 Multiplayer');
</script>

</body>
</html>
